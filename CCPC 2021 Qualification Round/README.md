## e

`s[n] = 0` 的情况很容易考虑，直接用map log(n)查询完事
`s[n] != 0` 要考虑同余域，要考虑的一些问题：
- 如何在同余域快速查询？ 应当考虑二分，在这里就直接用 `lower_bound` 二分方法
- 如何保证查询出来的东西是最小的？ 从n到1更新。
- 另外一个很重要的处理是有负数，因此求余数得额外构造一个函数来求。此外就是考虑`s[n]` 为负的情况。有两种处理方案，一种是将s数组和查询都正负变换，另一种做法是复杂的讨论。这里的解法用的是前一种方法。
- 另外一个事情就是对 map 的理解，map底层数据结构是一个pair，知道这一点挺重要的。另外就是map内置的 `count` 和 `insert` 方法。

## k
一道中等难度的图论题，结论是：对于联通块，权值最高的点一定是最 后的落点，但是从高向下考虑比较难度大，不容易实现。因此应该从反方向考虑建树。

建树过程中利用并查集降低复杂度，并且只加单向边就可以。最后一个dfs 在O（n）时间输出答案。

## f
dp + 后缀和 + 快速幂，考验基础功的题目，状态转移写了太久。
## p1439
一道求最长公共子序列的题目，最朴素的算法显然O(n^3)超时
- p1439-70 的解法主要是通过map加快动态规划的转移，mp[dp值]储存dp值对应的最早出现index，后面的dp用这个map来更新。但这种做法近似n方的时间复杂度，所以只拿到了70分 ;)。
- p1439 的解法有点单调栈的意思了，栈里的index是升序的，含义和map其实是相同的，比如栈内第5个元素代表长度为5LCS的最早index。用lower_bound加速转移，时间复杂度来到了O(nlog(n))。

写循环嵌套记得注意循环变量是不是复用了，很容易犯的一个粗心错误。

## p1280
一道比较简单的dp题目，dp[i] 表示 i~n 时间内的最长摸鱼时间。

某时刻如果没有此刻开始的任务，dp[i] = dp[i+1] + 1，否则就取任务结束时刻的dp最大值。

倒着搜，很有创新性的思路（题解是从[tutorial](https://www.luogu.com.cn/problem/solution/P1280)借鉴过来的），实际上正着搜也可以的。

时间复杂度是O(n)。

## p5858
一道O(n^2) dp题目，转移方程是dp[i][j] = max(dp[i-1][k])+j*a[i] (j-1<=k<=min(w, j-1+s))

由于需要某个区间内的最大值来更新，另外更新的窗口是一直移动的。

考虑利用单调队列维护最大值，使得每次更新的平均花费为O(1)。